@inherits BlazorContextMenu.MenuTreeComponent

@inject BlazorContextMenuSettings Settings
@inject IMenuTreeTraverser MenuTreeTraverser
@inject IInternalContextMenuHandler ContextMenuHandler

@namespace BlazorContextMenu

<li @attributes="Attributes"
    id="@Id"
    @onclick="OnClickInternal"
    class="@($"blazor-context-menu__item {ClassCalc}")"
    style="@($"display:{(Visible ? "block" : "none")};")"
    itemEnabled="@Enabled.ToWeb()"
    onmouseover="@(Enabled ? OnMouseOverString : string.Empty)"
    onmouseout="@(Enabled ? OnMouseOutString : string.Empty)"
    @ref="MenuItemElement">
    <CascadingValue Value="(MenuTreeComponent)this" Name="ParentComponent">
        @ChildContent
    </CascadingValue>
</li>

@code
{
    #region Parameters

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object> Attributes { get; set; }

    /// <summary>
    /// Allows you to override the default css class of the <see cref="Item"/>'s li element, for full customization.
    /// </summary>
    [Parameter]
    public string OverrideDefaultCssClass { get; set; }

    /// <summary>
    /// Allows you to override the default css class of the <see cref="Item"/>'s li element when disabled, for full customization.
    /// </summary>
    [Parameter]
    public string OverrideDefaultDisabledCssClass { get; set; }

    /// <summary>
    /// Allows you to override the default css class of the <see cref="Item"/>'s li element when it contains a <see cref="SubMenu"/>, for full customization.
    /// </summary>
    [Parameter]
    public string OverrideDefaultCssClassWithSubMenu { get; set; }

    /// <summary>
    /// Additional css class for the <see cref="Item"/>'s li element. Use this to extend the default css.
    /// </summary>
    [Parameter]
    public string CssClass { get; set; }

    /// <summary>
    /// Additional css class for the <see cref="Item"/>'s li element when disabled. Use this to extend the default css.
    /// </summary>
    [Parameter]
    public string DisabledCssClass { get; set; }

    /// <summary>
    /// Additional css class for the <see cref="Item"/>'s li element when it contains a <see cref="SubMenu"/>. Use this to extend the default css.
    /// </summary>
    [Parameter]
    public string CssClassWithSubMenu { get; set; }

    /// <summary>
    /// The menu item's onclick handler. A <see cref="ItemClickEventArgs"/> is passed to the action.
    /// If you want to cancel the click (i.e. stop the menu from closing), then set the "IsCanceled" event args property to "true".
    /// </summary>
    [Parameter]
    public EventCallback<ItemClickEventArgs> OnClick { get; set; }

    /// <summary>
    /// Sets the item's enabled state. Default <see cref="true" />.
    /// </summary>
    [Parameter]
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Sets the item's visible state. Default <see cref="true" />.
    /// </summary>
    [Parameter]
    public bool Visible { get; set; } = true;

    /// <summary>
    /// A handler that can be used to set the item's <see cref="Visible"/> or <see cref="Enabled"/> status dynamically.
    /// </summary>
    [Parameter]
    public EventCallback<ItemAppearingEventArgs> OnAppearing { get; set; }

    /// <summary>
    /// The id of the li element. This is optional.
    /// </summary>
    [Parameter]
    public string Id { get; set; }

    /// <summary>
    /// Allows you to override the default x position offset of the submenu (i.e. the distance of the submenu from it's parent menu).
    /// </summary>
    [Parameter]
    public int? SubmenuXOffset { get; set; }

    [Parameter]
    public RenderFragment ChildContent { get; set; }

    #endregion

    #region Properties

    protected string ClassCalc
    {
        get
        {
            BlazorContextMenuTemplate template = Settings.GetTemplate(Template);
            
            string[] classes = new string[4];
            
            if (Enabled)
            {
                classes[0] = OverrideDefaultCssClass ?? template.DefaultCssOverrides.MenuItemCssClass;
                classes[1] = CssClass ?? template.MenuItemCssClass;
            }
            else
            {
                classes[0] = OverrideDefaultDisabledCssClass ?? template.DefaultCssOverrides.MenuItemDisabledCssClass;
                classes[1] = DisabledCssClass ?? template.MenuItemDisabledCssClass;
            }

            if (MenuTreeTraverser.HasSubMenu(this))
            {
                classes[2] = OverrideDefaultCssClassWithSubMenu ?? template.DefaultCssOverrides.MenuItemWithSubMenuCssClass;
                classes[3] = CssClassWithSubMenu ?? template.MenuItemWithSubMenuCssClass;
            }

            return Helpers.AppendCssClasses(classes);
        }
    }

    protected ElementReference MenuItemElement { get; set; }
    
    protected string Template { get; set; }
    
    protected ContextMenu RootMenu { get; set; }
    
    protected ContextMenuBase ParentMenu { get; set; }

    private int Offset => SubmenuXOffset ?? Settings.GetTemplate(Template).SubMenuXPositionPixelsOffset;
    
    private string OnMouseOverString => $"blazorContextMenu.OnMenuItemMouseOver(event, {Offset}, this);";
    
    private string OnMouseOutString => "blazorContextMenu.OnMenuItemMouseOut(event);";

    #endregion
    
    #region Protected Methods

    protected override async Task OnInitializedAsync()
    {
        if (Id.IsNullOrEmpty())
            Id = Guid.NewGuid().ToString();
        
        if (MenuTreeTraverser.GetRootContextMenu(this) is not { } rootMenu)
            throw new Exception("Item component must be a child of a ContextMenu component");
        
        RootMenu = rootMenu;
        ParentMenu = MenuTreeTraverser.GetClosestContextMenu(this);
        Template = ParentMenu.GetActiveTemplate();

        if (!OnAppearing.HasDelegate)
            return;
        
        ItemAppearingEventArgs appearingArgs = new(RootMenu.Id, RootMenu.GetTarget(), RootMenu.GetTrigger(),
            this, Visible, Enabled, RootMenu.Data);
        
        await OnAppearing.InvokeAsync(appearingArgs);
        Visible = appearingArgs.IsVisible;
        Enabled = appearingArgs.IsEnabled;
    }
    
    protected async Task OnClickInternal(MouseEventArgs e)
    {
        if (!Enabled || !OnClick.HasDelegate)
            return;

        ItemClickEventArgs args = new(e, RootMenu.Id, RootMenu.GetTarget(), RootMenu.GetTrigger(),
            MenuItemElement, this, RootMenu.Data)
        {
            IsCanceled = !RootMenu.AutoHide
        };
            
        await OnClick.InvokeAsync(args);
            
        if (!args.IsCanceled)
            await ContextMenuHandler.HideMenu(RootMenu.Id);
    }

    #endregion
}